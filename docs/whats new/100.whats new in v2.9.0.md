---
title: What's New In LiteFlow v2.9.0?
date: 2022-10-07 12:43:18
permalink: /pages/8ff001/
---



## 前言

LiteFlow v2.9.0版本带来了大量的特性，一共19个issue，还有数不清的优化。是所有发布的版本中特性最多的一次。

我们纵向拓展了LiteFlow的深度，赋予新版本的LiteFlow在编排时拥有更多的能力，适应更多的场景。

我们也同时横向拓展了LiteFlow的广度，推出了规则插件机制，赋予LiteFlow能支持更多的中间件的能力。

让我们一起来看看此次2.9.0版本中我们新增了哪些激动人心的特性吧。



## 循环表达式

虽然之前LiteFlow在表达式层面拥有诸多的关键字，可以满足大部分的编排场景。但是在循环层面，并没有原生提供语法来支持。很多小伙伴只能依靠隐式流程自己来完成循环操作。

在2.9.0版本中，我们新增了`次数循环表达式`和`条件循环表达式`。

次数循环表达式：

```xml
<!-- 直接写数字 -->
<chain name="chain1">
    FOR(5).DO(THEN(a, b, c);
</chain>
<!-- 在java组件里获取次数 -->
<chain name="chain1">
    FOR(x).DO(THEN(a, b, c);
</chain>
```

条件循环表达式：

```xml
<chain name="chain1">
    WHILE(w).DO(THEN(a, b, c);
</chain>
```

退出循环关键字：

```xml
<!-- BREAK可以和FOR...DO连用 -->
<chain name="chain1">
    FOR(x).DO(THEN(a, b).BREAK(c);
</chain>
<!-- BREAK可以和WHILE...DO连用 -->
<chain name="chain1">
    WHILE(w).DO(THEN(a, b).BREAK(c);
</chain>
```

::: tip

关于循环表达式的详细说明请查看[循环编排](/pages/fbf715/)章节。

:::



## 中间件的原生存储支持

之前LiteFlow只支持本地文件和zk方式存储，如果你想用其他的方式存储规则，LiteFlow提供了扩展接口，需要使用者自己去实现。

这无疑增加了一些使用成本。

在v2.9.0版本中，官方从底层推出了规则存储插件机制，并一口气推出了SQL数据库，Nacos，Etcd的支持，当然之前的ZK支持也独立出了插件。

使用插件，你无需再去自己扩展接口实现。只需引入插件。配置参数即可。大大降低了使用成本。

当然，对于没提供的中间件插件实现，你依旧可以自行扩展去实现。

::: tip

ZK规则插件详细说明：[ZK规则文件配置源](/pages/ffc345/)

SQL数据库规则插件详细说明：[SQL数据库配置源](/pages/236b4f/)

Nacos规则插件详细说明：[Nacos配置源](/pages/09b776/)

Etcd规则插件详细说明：[Etcd配置源](/pages/4bfac2/)

:::



## 方法级的声明式组件

之前LiteFlow推出了声明式组件，不知道大家都用过没。

声明式组件有一个最大的好处就是无侵入，你仅需通过注解就可以定义出一个组件。提供了自由扩展的可能。

但是类声明组件也是需要一个类对应一个组件。如果你的组件超多，达到上百个，那就需要定义上百个类。造成了类爆炸的现象，不好管理。

v2.9.0推出的方法级的声明式组件正好能解决这个痛点。新版本允许你在一个类里通过方法上的注解完成多个组件的声明。这一切仅仅需要一个注解即可完成。

::: tip

关于方法级的声明式的详细使用方法请参考：[方法级别式声明](/pages/797830/)

:::



## 任意Bean均可引入至脚本

早在2.6.X的时候LiteFlow就支持了脚本编写，有些易变且简单的逻辑你可以用脚本来进行编写。

但是之前的版本，脚本里只能引用上下文。

有的小伙伴希望脚本拥有更多的能力，让脚本和java代码之间拥有更多的交互，比如用脚本读个文件？比如用脚本进行一次RPC的调用？

这次v2.9.0带来了新的特性，任意Bean均可引入至脚本，换而言之，就是在脚本里可以调用任意Java Bean的对象。

这一切只需要一个注解即可完成。

::: tip

关于脚本与Java之间交互的增强的详细使用方法请参考：[与Java进行交互](/pages/d861c8/)

:::



## 支持单组件的多定义

LiteFlow之前的版本是不支持单组件多定义的，也就是把一个组件定义成不同的NodeId。如果你这样去定义，那这个组件总是被最后一个NodeId所覆盖。

v2.9.0现在支持了这种定义方式，你可以用动态代码来构建组件，给同一个组件构建不同的nodeId。

::: tip

关于动态代码构建组件的详细使用方法请参考：[如何动态构造](/pages/6bc8fe/)

:::



## 组件级别的规则参数设置

之前LiteFlow在规则层面是没法给组件设置额外的参数的。

参数只有request层面的参数，由FlowExecutor调用的时候传入。大多数情况，reqeust传入的参数就已经够用了。

但是当相同组件进行编排时，可能要在不同的位置设置不同的组件级参数，就没办法做到了。

这次v2.9.0版本带来了这一特性的支持，新增了`data`关键词，你可以这样使用：

```xml
<chain name="chain1">
    cmpData = '{"name":"jack","age":27,"birth":"1995-10-01"}';

    THEN(
        a,
        b.data(cmpData),
        c
    );
</chain>
```

::: tip

关于组件参数的使用详细请参考：[组件参数](/pages/6e4d15/)

:::



## 选择组件支持标签选择

LiteFlow以前的版本对于选择组件返回参数的定义是：只能返回可执行项的id，比如：

```xml
<chain name="chain1">
    SWITCH(s).to(a, b);
</chain>
```

s组件，要么返回a，要么返回b，要么返回空，除此之外的任何其他返回都会报错提示。

v2.9.0现在支持对tag的选择了，你可以如下定义tag：

```xml
<chain name="chain1">
    SWITCH(s).to(a.tag("cat"), b.tag("dog"));
</chain>
```

那么要选择到b组件，除了可以返回"b"，还可以写返回："tag:dog"。

::: tip

关于选择支持标签写法的使用详细请参考：[选择组件](/pages/c0f5d7/)

:::



## 去除了旧表达式的支持

LiteFlow在v2.6.X和v2.7.X阶段是用标签表达式来编排的。

在v2.8.X版本全面转向了EL表达式，但是也是支持标签表达式的。算是一个兼容的版本。所以你会看到EL表达式的规则文件会要求用`el.xml`这种形式来定义。

但是在v2.9.0中，我们移除了标签表达式的支持。以后将只会支持全新的EL表达式。

所以从v2.9.0开始不再有文件扩展名的约束，你定义成`*.xml`还是`*.el.xml`都会支持。

为了兼容大家的文档阅读体验，避免造成理解上的错乱，文档中的示例还是保留了`*.el.xml`这种形式。这点大家注意下。